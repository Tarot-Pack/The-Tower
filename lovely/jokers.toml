[manifest]
version = "1.0.0"
dump_lua = true
priority = 999

[[patches]]
[patches.pattern]
target = '''=[SMODS _ "src/utils.lua"]'''
pattern = '''card_eval_status_text(scored_card, 'jokers', nil, percent, nil, {message = localize{type='variable',key= amount > 0 and 'a_xmult' or 'a_xmult_minus',vars={amount}}, Xmult_mod =  amount, colour =  G.C.EDITION, edition = true})'''
position = "at"
payload = '''
card_eval_status_text(scored_card, 'jokers', nil, percent, nil, {message = localize{type='variable',key= to_big(amount) > to_big(0) and 'a_xmult' or 'a_xmult_minus',vars={amount}}, Xmult_mod =  amount, colour =  G.C.EDITION, edition = true})
'''
match_indent = true

[[patches]]
[patches.pattern]
target = '''functions/button_callbacks.lua'''
pattern = '''if card.ability.set == 'Booster' and not nosave and G.STATE == G.STATES.SHOP then'''
position = "before"
payload = '''
if card.ability.consumeable then
    SMODS.calculate_context({ tower_before_consumable_used = true, consumeable = card, area = card.from_area })
end
'''
match_indent = true

[[patches]]
[patches.pattern]
target = '''=[SMODS _ "src/utils.lua"]'''
pattern = '''local available_rarities = copy_table(SMODS.ObjectTypes[_pool_key].rarities)'''
position = "after"
payload = '''
available_rarities = available_rarities or {}
'''
match_indent = true



[[patches]]
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = '''if obj and obj.set_badges and type(obj.set_badges) == 'function' then'''
position = "before"
payload = '''
if (card.ability and card.ability.set == "Joker") and 
((not ((G.GAME and G.GAME.tower_global_joker_invert) or false) and (card.ability and card.ability.tower_joker_invert))
or (((G.GAME and G.GAME.tower_global_joker_invert) or false) and (not ((card.ability and card.ability.tower_joker_invert) or false)))) then
    badges[#badges+1] = create_badge(localize('k_tower_inverted'), Tower.ChipMultGrad, nil, 1 )
    loc_vars = loc_vars or {}
    loc_vars.tower_joker_invert = true
end'''
match_indent = true


[[patches]]
[patches.pattern]
target = '''functions/UI_definitions.lua'''
pattern = '''if obj and obj.set_badges and type(obj.set_badges) == 'function' then'''
position = "before"
payload = '''
if card.ability and card.ability.immutable and card.ability.immutable.tower_force_gameset then
    badges[#badges+1] = create_badge(localize('cry_gameset_' .. (card.ability.immutable.tower_force_gameset)), G.C.CRY_GREENGRADIENT, nil, 1.2 )
end
if card.ability and card.ability.immutable.tower_empowered then
    badges[#badges+1] = create_badge(localize({ type = "variable", key = "tower_empowered_level", vars = { Tower.ToRoman(card.ability.immutable.tower_empowered) } }), Tower.EmpoweredColour, nil, 1 )
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = '''=[SMODS Cryptid "lib/gameset.lua"]'''
pattern = '''if card.force_gameset then'''
position = "before"
payload = '''
if card.ability and card.ability.immutable and card.ability.immutable.tower_force_gameset then
    return card.tower_force_gameset
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = '''=[SMODS _ "src/card_draw.lua"]'''
pattern = '''elseif self.children.floating_sprite then'''
position = "after"
payload = '''
self.children.floating_sprite:set_sprite_pos(self.config.center.soul_pos)
'''
match_indent = true

[[patches]]
[patches.pattern]
target = '''=[SMODS entr "lib/hooks.lua"]'''
pattern = '''if self.config.center.tsoul_pos then'''
position = "after"
payload = '''
self.children.floating_sprite:set_sprite_pos(self.config.center.tsoul_pos);
if self.config.center.tsoul_pos.extra then
    self.children.floating_sprite2:set_sprite_pos(self.config.center.tsoul_pos.extra);
end
'''
match_indent = true

[[patches]]
[patches.pattern]
target = '''=[SMODS _ "src/game_object.lua"]'''
pattern = '''if not card then'''
position = "before"
payload = '''local TOWER_IS_FAKE_CARD = not card'''
match_indent = true

[[patches]]
[patches.pattern]
target = '''functions/common_events.lua'''
pattern = "local info_queue = {}"
position = "after"
payload = '''
if G.GAME and G.GAME.banned_keys and G.GAME.banned_keys[_c.key] and Tower.Config.show_banned then
    if desc_nodes == full_UI_table.main and not full_UI_table.name then
        info_queue[#info_queue+1] = G.P_CENTERS.desc_tower_banned_card
    else
        G.TOWER_BANNED_OVERRIDE_DESC = true
    end
end'''
match_indent = true


[[patches]]
[patches.pattern]
target = "functions/misc_functions.lua"
pattern = "function localize(args, misc_cat)"
position = "after"
payload = '''
if G.TOWER_BANNED_OVERRIDE_DESC and args.type == "descriptions" then
    G.TOWER_BANNED_OVERRIDE_DESC = false
    args.set = G.P_CENTERS.desc_tower_banned_card.set
    args.key = G.P_CENTERS.desc_tower_banned_card.key
end
'''
match_indent = true

[[patches]]
[patches.pattern]
target = '''functions/common_events.lua'''
pattern = "local info_queue = {}"
position = "after"
payload = '''
if desc_nodes == full_UI_table.main and not full_UI_table.name then
    for i, v in ipairs(G.fortunes or {}) do
        if v.config.center.tower_boost(_c) then
            local vars = {}
            if v.config.center.secondary_loc_vars then
                vars = v.config.center:secondary_loc_vars(info_queue, v).vars
            end
            info_queue[#info_queue+1] = {key = v.config.center.key .. '_secondary', set = "Fortune", specific_vars = vars}
        end
    end
end
'''
match_indent = true

[[patches]]
[patches.pattern]
target = "functions/misc_functions.lua"
pattern = "for k, v in ipairs(G.GAME.tags) do"
position = "before"
payload = '''
local fortunes = {}
for i, v in ipairs(G.fortunes or {}) do
    fortunes[#fortunes+1] = v:save()
end
'''

match_indent = true
[[patches]]
[patches.pattern]
target = "functions/misc_functions.lua"
pattern = "tags = tags,"
position = "after"
payload = '''
fortunes = fortunes,
'''
match_indent = true

[[patches]]
[patches.pattern]
target = '''=[SMODS _ "src/utils.lua"]'''
pattern = "function SMODS.get_card_areas(_type, _context)"
position = "after"
payload = '''
if _type == 'fortunes' then
    local t = { G.fortunes }
    return t
end
'''
match_indent = true
[[patches]]
[patches.pattern]
target = '''=[SMODS _ "src/utils.lua"]'''
pattern = """local flags = {}
    if _type == 'jokers' then"""
position = "after"
payload = '''
for _, area in ipairs(SMODS.get_card_areas('fortunes')) do
    for _, _card in ipairs(area) do
        --calculate the joker effects
        local eval, post = eval_card(_card, context)
        if args and args.main_scoring and eval.jokers then
            eval.jokers.juice_card = eval.jokers.juice_card or eval.jokers.card or _card
            eval.jokers.message_card = eval.jokers.message_card or context.other_card
        end

        local effects = {eval}
        for _,v in ipairs(post) do effects[#effects+1] = v end

        if context.other_joker then
            for k, v in pairs(effects[1]) do
                v.other_card = _card
            end
        end

        if eval.retriggers then
            context.retrigger_joker = true
            for rt = 1, #eval.retriggers do
                context.retrigger_joker = eval.retriggers[rt].retrigger_card
                local rt_eval, rt_post = eval_card(_card, context)
                if args and args.main_scoring and rt_eval.jokers then
                    rt_eval.jokers.juice_card = rt_eval.jokers.juice_card or rt_eval.jokers.card or _card
                    rt_eval.jokers.message_card = rt_eval.jokers.message_card or context.other_card
                end
                table.insert(effects, {retriggers = eval.retriggers[rt]})
                table.insert(effects, rt_eval)
                for _,v in ipairs(rt_post) do effects[#effects+1] = v end
            end
            context.retrigger_joker = nil
        end
        if return_table then
            for _,v in ipairs(effects) do
                if v.jokers and not v.jokers.card then v.jokers.card = _card end
                return_table[#return_table+1] = v
            end
        else
            local f = SMODS.trigger_effects(effects, _card)
            for k,v in pairs(f) do flags[k] = v end
            if flags.numerator then context.numerator = flags.numerator end
            if flags.denominator then context.denominator = flags.denominator end
        end
    end
end
'''
match_indent = true

